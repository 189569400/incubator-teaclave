/* automatically generated by rust-bindgen 0.57.0 */

pub const TVM_VERSION: &'static [u8; 9usize] = b"0.8.dev0\0";
pub const DLPACK_VERSION: u32 = 40;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " \\brief CPU device"]
pub const DLDeviceType_kDLCPU: DLDeviceType = 1;
#[doc = " \\brief CUDA GPU device"]
pub const DLDeviceType_kDLCUDA: DLDeviceType = 2;
#[doc = " \\brief Pinned CUDA CPU memory by cudaMallocHost"]
pub const DLDeviceType_kDLCUDAHost: DLDeviceType = 3;
#[doc = " \\brief OpenCL devices."]
pub const DLDeviceType_kDLOpenCL: DLDeviceType = 4;
#[doc = " \\brief Vulkan buffer for next generation graphics."]
pub const DLDeviceType_kDLVulkan: DLDeviceType = 7;
#[doc = " \\brief Metal for Apple GPU."]
pub const DLDeviceType_kDLMetal: DLDeviceType = 8;
#[doc = " \\brief Verilog simulator buffer"]
pub const DLDeviceType_kDLVPI: DLDeviceType = 9;
#[doc = " \\brief ROCm GPUs for AMD GPUs"]
pub const DLDeviceType_kDLROCM: DLDeviceType = 10;
#[doc = " \\brief Reserved extension device type,"]
#[doc = " used for quickly test extension device"]
#[doc = " The semantics can differ depending on the implementation."]
pub const DLDeviceType_kDLExtDev: DLDeviceType = 12;
#[doc = " \\brief The device type in DLDevice."]
pub type DLDeviceType = ::std::os::raw::c_uint;
#[doc = " \\brief A Device for Tensor and operator."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DLDevice {
    #[doc = " \\brief The device type used in the device."]
    pub device_type: DLDeviceType,
    #[doc = " \\brief The device index"]
    pub device_id: ::std::os::raw::c_int,
}
impl Default for DLDevice {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief signed integer"]
pub const DLDataTypeCode_kDLInt: DLDataTypeCode = 0;
#[doc = " \\brief unsigned integer"]
pub const DLDataTypeCode_kDLUInt: DLDataTypeCode = 1;
#[doc = " \\brief IEEE floating point"]
pub const DLDataTypeCode_kDLFloat: DLDataTypeCode = 2;
#[doc = " \\brief Opaque handle type, reserved for testing purposes."]
#[doc = " Frameworks need to agree on the handle data type for the exchange to be well-defined."]
pub const DLDataTypeCode_kDLOpaqueHandle: DLDataTypeCode = 3;
#[doc = " \\brief bfloat16"]
pub const DLDataTypeCode_kDLBfloat: DLDataTypeCode = 4;
#[doc = " \\brief complex number"]
#[doc = " (C/C++/Python layout: compact struct per complex number)"]
pub const DLDataTypeCode_kDLComplex: DLDataTypeCode = 5;
#[doc = " \\brief The type code options DLDataType."]
pub type DLDataTypeCode = ::std::os::raw::c_uint;
#[doc = " \\brief The data type the tensor can hold."]
#[doc = ""]
#[doc = "  Examples"]
#[doc = "   - float: type_code = 2, bits = 32, lanes=1"]
#[doc = "   - float4(vectorized 4 float): type_code = 2, bits = 32, lanes=4"]
#[doc = "   - int8: type_code = 0, bits = 8, lanes=1"]
#[doc = "   - std::complex<float>: type_code = 5, bits = 64, lanes = 1"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct DLDataType {
    #[doc = " \\brief Type code of base types."]
    #[doc = " We keep it uint8_t instead of DLDataTypeCode for minimal memory"]
    #[doc = " footprint, but the value should be one of DLDataTypeCode enum values."]
    pub code: u8,
    #[doc = " \\brief Number of bits, common choices are 8, 16, 32."]
    pub bits: u8,
    #[doc = " \\brief Number of lanes in the type, used for vector types."]
    pub lanes: u16,
}
#[doc = " \\brief Plain C Tensor object, does not manage memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DLTensor {
    #[doc = " \\brief The opaque data pointer points to the allocated data. This will be"]
    #[doc = " CUDA device pointer or cl_mem handle in OpenCL. This pointer is always"]
    #[doc = " aligned to 256 bytes as in CUDA."]
    #[doc = ""]
    #[doc = " For given DLTensor, the size of memory required to store the contents of"]
    #[doc = " data is calculated as follows:"]
    #[doc = ""]
    #[doc = " \\code{.c}"]
    #[doc = " static inline size_t GetDataSize(const DLTensor* t) {"]
    #[doc = "   size_t size = 1;"]
    #[doc = "   for (tvm_index_t i = 0; i < t->ndim; ++i) {"]
    #[doc = "     size *= t->shape[i];"]
    #[doc = "   }"]
    #[doc = "   size *= (t->dtype.bits * t->dtype.lanes + 7) / 8;"]
    #[doc = "   return size;"]
    #[doc = " }"]
    #[doc = " \\endcode"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " \\brief The device of the tensor"]
    pub device: DLDevice,
    #[doc = " \\brief Number of dimensions"]
    pub ndim: ::std::os::raw::c_int,
    #[doc = " \\brief The data type of the pointer"]
    pub dtype: DLDataType,
    #[doc = " \\brief The shape of the tensor"]
    pub shape: *mut i64,
    #[doc = " \\brief strides of the tensor (in number of elements, not bytes)"]
    #[doc = "  can be NULL, indicating tensor is compact and row-majored."]
    pub strides: *mut i64,
    #[doc = " \\brief The offset in bytes to the beginning pointer to data"]
    pub byte_offset: u64,
}
impl Default for DLTensor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief C Tensor object, manage memory of DLTensor. This data structure is"]
#[doc = "  intended to facilitate the borrowing of DLTensor by another framework. It is"]
#[doc = "  not meant to transfer the tensor. When the borrowing framework doesn't need"]
#[doc = "  the tensor, it should call the deleter to notify the host that the resource"]
#[doc = "  is no longer needed."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct DLManagedTensor {
    #[doc = " \\brief DLTensor which is being memory managed"]
    pub dl_tensor: DLTensor,
    #[doc = " \\brief the context of the original host framework of DLManagedTensor in"]
    #[doc = "   which DLManagedTensor is used in the framework. It can also be NULL."]
    pub manager_ctx: *mut ::std::os::raw::c_void,
    #[doc = " \\brief Destructor signature void (*)(void*) - this should be called"]
    #[doc = "   to destruct manager_ctx which holds the DLManagedTensor. It can be NULL"]
    #[doc = "   if there is no way for the caller to provide a reasonable destructor."]
    #[doc = "   The destructors deletes the argument self as well."]
    pub deleter: ::std::option::Option<unsafe extern "C" fn(self_: *mut DLManagedTensor)>,
}
impl Default for DLManagedTensor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief type of array index."]
pub type tvm_index_t = i64;
pub const TVMDeviceExtType_kDLAOCL: TVMDeviceExtType = 5;
pub const TVMDeviceExtType_kDLSDAccel: TVMDeviceExtType = 6;
pub const TVMDeviceExtType_kOpenGL: TVMDeviceExtType = 11;
pub const TVMDeviceExtType_kDLMicroDev: TVMDeviceExtType = 13;
pub const TVMDeviceExtType_kDLHexagon: TVMDeviceExtType = 14;
pub const TVMDeviceExtType_kDLWebGPU: TVMDeviceExtType = 15;
#[doc = " \\brief Extension device types in TVM"]
pub type TVMDeviceExtType = ::std::os::raw::c_uint;
pub const TVMArgTypeCode_kTVMArgInt: TVMArgTypeCode = 0;
pub const TVMArgTypeCode_kTVMArgFloat: TVMArgTypeCode = 2;
pub const TVMArgTypeCode_kTVMOpaqueHandle: TVMArgTypeCode = 3;
pub const TVMArgTypeCode_kTVMNullptr: TVMArgTypeCode = 4;
pub const TVMArgTypeCode_kTVMDataType: TVMArgTypeCode = 5;
pub const TVMArgTypeCode_kDLDevice: TVMArgTypeCode = 6;
pub const TVMArgTypeCode_kTVMDLTensorHandle: TVMArgTypeCode = 7;
pub const TVMArgTypeCode_kTVMObjectHandle: TVMArgTypeCode = 8;
pub const TVMArgTypeCode_kTVMModuleHandle: TVMArgTypeCode = 9;
pub const TVMArgTypeCode_kTVMPackedFuncHandle: TVMArgTypeCode = 10;
pub const TVMArgTypeCode_kTVMStr: TVMArgTypeCode = 11;
pub const TVMArgTypeCode_kTVMBytes: TVMArgTypeCode = 12;
pub const TVMArgTypeCode_kTVMNDArrayHandle: TVMArgTypeCode = 13;
pub const TVMArgTypeCode_kTVMObjectRValueRefArg: TVMArgTypeCode = 14;
pub const TVMArgTypeCode_kTVMExtBegin: TVMArgTypeCode = 15;
pub const TVMArgTypeCode_kTVMNNVMFirst: TVMArgTypeCode = 16;
pub const TVMArgTypeCode_kTVMNNVMLast: TVMArgTypeCode = 20;
pub const TVMArgTypeCode_kTVMExtReserveEnd: TVMArgTypeCode = 64;
pub const TVMArgTypeCode_kTVMExtEnd: TVMArgTypeCode = 128;
#[doc = " \\brief The type code in used and only used in TVM FFI for argument passing."]
#[doc = ""]
#[doc = " DLPack consistency:"]
#[doc = " 1) kTVMArgInt is compatible with kDLInt"]
#[doc = " 2) kTVMArgFloat is compatible with kDLFloat"]
#[doc = " 3) kDLUInt is not in ArgTypeCode, but has a spared slot"]
#[doc = ""]
#[doc = " Downstream consistency:"]
#[doc = " The kDLInt, kDLUInt, kDLFloat are kept consistent with the original ArgType code"]
#[doc = ""]
#[doc = " It is only used in argument passing, and should not be confused with"]
#[doc = " DataType::TypeCode, which is DLPack-compatible."]
#[doc = ""]
#[doc = " \\sa tvm::runtime::DataType::TypeCode"]
pub type TVMArgTypeCode = ::std::os::raw::c_uint;
#[doc = " \\brief the array handle"]
pub type TVMArrayHandle = *mut DLTensor;
#[doc = " \\brief Union type of values"]
#[doc = "  being passed through API and function calls."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union TVMValue {
    pub v_int64: i64,
    pub v_float64: f64,
    pub v_handle: *mut ::std::os::raw::c_void,
    pub v_str: *const ::std::os::raw::c_char,
    pub v_type: DLDataType,
    pub v_device: DLDevice,
    _bindgen_union_align: u64,
}
impl Default for TVMValue {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief Byte array type used to pass in byte array"]
#[doc = "  When kTVMBytes is used as data type."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct TVMByteArray {
    pub data: *const ::std::os::raw::c_char,
    pub size: size_t,
}
impl Default for TVMByteArray {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief Handle to TVM runtime modules."]
pub type TVMModuleHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to packed function handle."]
pub type TVMFunctionHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to hold return value."]
pub type TVMRetValueHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief The stream that is specific to device"]
#[doc = " can be NULL, which indicates the default one."]
pub type TVMStreamHandle = *mut ::std::os::raw::c_void;
#[doc = " \\brief Handle to Object."]
pub type TVMObjectHandle = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " \\brief Used for implementing C API function."]
    #[doc = "  Set last error message before return."]
    #[doc = " \\param msg The error message to be set."]
    pub fn TVMAPISetLastError(msg: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief return str message of the last error"]
    #[doc = "  all function in this file will return 0 when success"]
    #[doc = "  and -1 when an error occurred,"]
    #[doc = "  TVMGetLastError can be called to retrieve the error"]
    #[doc = ""]
    #[doc = "  this function is threadsafe and can be called by different thread"]
    #[doc = "  \\return error info"]
    pub fn TVMGetLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Load module from file."]
    #[doc = " \\param file_name The file name to load the module from."]
    #[doc = " \\param format The format of the module."]
    #[doc = " \\param out The result module"]
    #[doc = ""]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    #[doc = " \\note The resulting module do not contain import relation."]
    #[doc = "  It can be reconstructed by TVMModImport."]
    pub fn TVMModLoadFromFile(
        file_name: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        out: *mut TVMModuleHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add dep to mod's dependency."]
    #[doc = "  This allows functions in this module to use modules."]
    #[doc = ""]
    #[doc = " \\param mod The module handle."]
    #[doc = " \\param dep The dependent module to be imported."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMModImport(mod_: TVMModuleHandle, dep: TVMModuleHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get function from the module."]
    #[doc = " \\param mod The module handle."]
    #[doc = " \\param func_name The name of the function."]
    #[doc = " \\param query_imports Whether to query imported modules"]
    #[doc = " \\param out The result function, can be NULL if it is not available."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMModGetFunction(
        mod_: TVMModuleHandle,
        func_name: *const ::std::os::raw::c_char,
        query_imports: ::std::os::raw::c_int,
        out: *mut TVMFunctionHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free the Module"]
    #[doc = " \\param mod The module to be freed."]
    #[doc = ""]
    #[doc = " \\note This may not free up the module's resources."]
    #[doc = "  If there is active TVMFunctionHandle uses the module"]
    #[doc = "  Or if this module is imported by another active module."]
    #[doc = ""]
    #[doc = "  The all functions remains valid until TVMFuncFree is called."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMModFree(mod_: TVMModuleHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free the function when it is no longer needed."]
    #[doc = " \\param func The function handle"]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMFuncFree(func: TVMFunctionHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Call a Packed TVM Function."]
    #[doc = ""]
    #[doc = " \\param func node handle of the function."]
    #[doc = " \\param arg_values The arguments"]
    #[doc = " \\param type_codes The type codes of the arguments"]
    #[doc = " \\param num_args Number of arguments."]
    #[doc = ""]
    #[doc = " \\param ret_val The return value."]
    #[doc = " \\param ret_type_code the type code of return value."]
    #[doc = ""]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    #[doc = " \\note TVM calls always exchanges with type bits=64, lanes=1"]
    #[doc = ""]
    #[doc = " \\note API calls always exchanges with type bits=64, lanes=1"]
    #[doc = "   If API call returns container handles (e.g. FunctionHandle)"]
    #[doc = "   these handles should be managed by the front-end."]
    #[doc = "   The front-end need to call free function (e.g. TVMFuncFree)"]
    #[doc = "   to free these handles."]
    pub fn TVMFuncCall(
        func: TVMFunctionHandle,
        arg_values: *mut TVMValue,
        type_codes: *mut ::std::os::raw::c_int,
        num_args: ::std::os::raw::c_int,
        ret_val: *mut TVMValue,
        ret_type_code: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the return value of TVMPackedCFunc."]
    #[doc = ""]
    #[doc = "  This function is called by TVMPackedCFunc to set the return value."]
    #[doc = "  When this function is not called, the function returns null by default."]
    #[doc = ""]
    #[doc = " \\param ret The return value handle, pass by ret in TVMPackedCFunc"]
    #[doc = " \\param value The value to be returned."]
    #[doc = " \\param type_code The type of the value to be returned."]
    #[doc = " \\param num_ret Number of return values, for now only 1 is supported."]
    pub fn TVMCFuncSetReturn(
        ret: TVMRetValueHandle,
        value: *mut TVMValue,
        type_code: *mut ::std::os::raw::c_int,
        num_ret: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Inplace translate callback argument value to return value."]
    #[doc = "  This is only needed for non-POD arguments."]
    #[doc = ""]
    #[doc = " \\param value The value to be translated."]
    #[doc = " \\param code The type code to be translated."]
    #[doc = " \\note This function will do a shallow copy when necessary."]
    #[doc = ""]
    #[doc = " \\return 0 when success, -1 when failure happens."]
    pub fn TVMCbArgToReturn(
        value: *mut TVMValue,
        code: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief C type of packed function."]
#[doc = ""]
#[doc = " \\param args The arguments"]
#[doc = " \\param type_codes The type codes of the arguments"]
#[doc = " \\param num_args Number of arguments."]
#[doc = " \\param ret The return value handle."]
#[doc = " \\param resource_handle The handle additional resouce handle from fron-end."]
#[doc = " \\return 0 if success, -1 if failure happens, set error via TVMAPISetLastError."]
#[doc = " \\sa TVMCFuncSetReturn"]
pub type TVMPackedCFunc = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut TVMValue,
        type_codes: *mut ::std::os::raw::c_int,
        num_args: ::std::os::raw::c_int,
        ret: TVMRetValueHandle,
        resource_handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " \\brief C callback to free the resource handle in C packed function."]
#[doc = " \\param resource_handle The handle additional resouce handle from fron-end."]
pub type TVMPackedCFuncFinalizer =
    ::std::option::Option<unsafe extern "C" fn(resource_handle: *mut ::std::os::raw::c_void)>;
#[doc = " \\brief Signature for extension function declarer."]
#[doc = ""]
#[doc = "  TVM call this function to get the extension functions"]
#[doc = "  The declarer will call register_func to register function and their name."]
#[doc = ""]
#[doc = " \\param register_func_handle The register function"]
#[doc = " \\return 0 if success, -1 if failure happens"]
pub type TVMExtensionFuncDeclarer = ::std::option::Option<
    unsafe extern "C" fn(register_func_handle: TVMFunctionHandle) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief Wrap a TVMPackedCFunc to become a FunctionHandle."]
    #[doc = ""]
    #[doc = " The resource_handle will be managed by TVM API, until the function is no longer used."]
    #[doc = ""]
    #[doc = " \\param func The packed C function."]
    #[doc = " \\param resource_handle The resource handle from front-end, can be NULL."]
    #[doc = " \\param fin The finalizer on resource handle when the FunctionHandle get freed, can be NULL"]
    #[doc = " \\param out the result function handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMFuncCreateFromCFunc(
        func: TVMPackedCFunc,
        resource_handle: *mut ::std::os::raw::c_void,
        fin: TVMPackedCFuncFinalizer,
        out: *mut TVMFunctionHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Register the function to runtime's global table."]
    #[doc = ""]
    #[doc = " The registered function then can be pulled by the backend by the name."]
    #[doc = ""]
    #[doc = " \\param name The name of the function."]
    #[doc = " \\param f The function to be registered."]
    #[doc = " \\param override Whether allow override already registered function."]
    pub fn TVMFuncRegisterGlobal(
        name: *const ::std::os::raw::c_char,
        f: TVMFunctionHandle,
        override_: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get a global function."]
    #[doc = ""]
    #[doc = " \\param name The name of the function."]
    #[doc = " \\param out the result function pointer, NULL if it does not exist."]
    #[doc = ""]
    #[doc = " \\note The function handle of global function is managed by TVM runtime,"]
    #[doc = "  So TVMFuncFree is should not be called when it get deleted."]
    pub fn TVMFuncGetGlobal(
        name: *const ::std::os::raw::c_char,
        out: *mut TVMFunctionHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief List all the globally registered function name"]
    #[doc = " \\param out_size The number of functions"]
    #[doc = " \\param out_array The array of function names."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMFuncListGlobalNames(
        out_size: *mut ::std::os::raw::c_int,
        out_array: *mut *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove a global function."]
    #[doc = " \\param name The name of the function."]
    pub fn TVMFuncRemoveGlobal(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate a nd-array's memory,"]
    #[doc = "  including space of shape, of given spec."]
    #[doc = ""]
    #[doc = " \\param shape The shape of the array, the data content will be copied to out"]
    #[doc = " \\param ndim The number of dimension of the array."]
    #[doc = " \\param dtype_code The type code of the dtype"]
    #[doc = " \\param dtype_bits The number of bits of dtype"]
    #[doc = " \\param dtype_lanes The number of lanes in the dtype."]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param out The output handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayAlloc(
        shape: *const tvm_index_t,
        ndim: ::std::os::raw::c_int,
        dtype_code: ::std::os::raw::c_int,
        dtype_bits: ::std::os::raw::c_int,
        dtype_lanes: ::std::os::raw::c_int,
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        out: *mut TVMArrayHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free the TVM Array."]
    #[doc = " \\param handle The array handle to be freed."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayFree(handle: TVMArrayHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Copy array data from CPU byte array."]
    #[doc = " \\param handle The array handle."]
    #[doc = " \\param data the data pointer"]
    #[doc = " \\param nbytes The number of bytes to copy."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayCopyFromBytes(
        handle: TVMArrayHandle,
        data: *mut ::std::os::raw::c_void,
        nbytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Copy array data to CPU byte array."]
    #[doc = " \\param handle The array handle."]
    #[doc = " \\param data the data pointer"]
    #[doc = " \\param nbytes The number of bytes to copy."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayCopyToBytes(
        handle: TVMArrayHandle,
        data: *mut ::std::os::raw::c_void,
        nbytes: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Copy the array, both from and to must be valid during the copy."]
    #[doc = " \\param from The array to be copied from."]
    #[doc = " \\param to The target space."]
    #[doc = " \\param stream The stream where the copy happens, can be NULL."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayCopyFromTo(
        from: TVMArrayHandle,
        to: TVMArrayHandle,
        stream: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Produce an array from the DLManagedTensor that shares data memory"]
    #[doc = " with the DLManagedTensor."]
    #[doc = " \\param from The source DLManagedTensor."]
    #[doc = " \\param out The output array handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayFromDLPack(
        from: *mut DLManagedTensor,
        out: *mut TVMArrayHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Produce a DLMangedTensor from the array that shares data memory with"]
    #[doc = " the array."]
    #[doc = " \\param from The source array."]
    #[doc = " \\param out The DLManagedTensor handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMArrayToDLPack(
        from: TVMArrayHandle,
        out: *mut *mut DLManagedTensor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Delete (free) a DLManagedTensor's data."]
    #[doc = " \\param dltensor Pointer to the DLManagedTensor."]
    pub fn TVMDLManagedTensorCallDeleter(dltensor: *mut DLManagedTensor);
}
extern "C" {
    #[doc = " \\brief Create a new runtime stream."]
    #[doc = ""]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param out The new stream handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMStreamCreate(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        out: *mut TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free a created stream handle."]
    #[doc = ""]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param stream The stream to be freed."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMStreamFree(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        stream: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the runtime stream of current thread to be stream."]
    #[doc = "  The subsequent calls to the same device_type"]
    #[doc = "  will use the setted stream handle."]
    #[doc = "  The specific type of stream is runtime device dependent."]
    #[doc = ""]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param handle The stream handle."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMSetStream(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        handle: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Wait until all computations on stream completes."]
    #[doc = ""]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param stream The stream to be synchronized."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMSynchronize(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        stream: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Synchronize two streams of execution."]
    #[doc = ""]
    #[doc = " \\param device_type The device type."]
    #[doc = " \\param device_id The device id."]
    #[doc = " \\param src The source stream to synchronize."]
    #[doc = " \\param dst The destination stream to synchronize."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMStreamStreamSynchronize(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        src: TVMStreamHandle,
        dst: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the type_index from an object."]
    #[doc = ""]
    #[doc = " \\param obj The object handle."]
    #[doc = " \\param out_tindex the output type index."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMObjectGetTypeIndex(
        obj: TVMObjectHandle,
        out_tindex: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Convert type key to type index."]
    #[doc = " \\param type_key The key of the type."]
    #[doc = " \\param out_tindex the corresponding type index."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMObjectTypeKey2Index(
        type_key: *const ::std::os::raw::c_char,
        out_tindex: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Increase the reference count of an object."]
    #[doc = ""]
    #[doc = " \\param obj The object handle."]
    #[doc = " \\note Internally we increase the reference counter of the object."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMObjectRetain(obj: TVMObjectHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free the object."]
    #[doc = ""]
    #[doc = " \\param obj The object handle."]
    #[doc = " \\note Internally we decrease the reference counter of the object."]
    #[doc = "       The object will be freed when every reference to the object are removed."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMObjectFree(obj: TVMObjectHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free a TVMByteArray returned from TVMFuncCall, and associated memory."]
    #[doc = " \\param arr The TVMByteArray instance."]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn TVMByteArrayFree(arr: *mut TVMByteArray) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate a data space on device."]
    #[doc = " \\param dev The device to perform operation."]
    #[doc = " \\param nbytes The number of bytes in memory."]
    #[doc = " \\param alignment The alignment of the memory."]
    #[doc = " \\param type_hint The type of elements. Only needed by certain backends such"]
    #[doc = "                   as nbytes & alignment are sufficient for most backends."]
    #[doc = " \\param out_data The allocated device pointer."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMDeviceAllocDataSpace(
        dev: DLDevice,
        nbytes: size_t,
        alignment: size_t,
        type_hint: DLDataType,
        out_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate a data space on device with special memory scope."]
    #[doc = " \\note The memory could use a special multi-dimensional memory layout."]
    #[doc = "       That is why we pass shape and dtype instead of raw number of bytes."]
    #[doc = " \\param dev The device to perform operation."]
    #[doc = " \\param ndim The number of dimension of the tensor."]
    #[doc = " \\param shape The shape of the tensor."]
    #[doc = " \\param dtype The type of elements."]
    #[doc = " \\param mem_scope The memory scope of the tensor,"]
    #[doc = "        can be nullptr, which indicate the default global DRAM"]
    #[doc = " \\param out_data The allocated device pointer."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMDeviceAllocDataSpaceWithScope(
        dev: DLDevice,
        ndim: ::std::os::raw::c_int,
        shape: *const i64,
        dtype: DLDataType,
        mem_scope: *const ::std::os::raw::c_char,
        out_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Free a data space on device."]
    #[doc = " \\param dev The device to perform operation."]
    #[doc = " \\param ptr The data space."]
    #[doc = " \\return 0 when success, -1 when failure happens"]
    pub fn TVMDeviceFreeDataSpace(
        dev: DLDevice,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Copy data from one place to another."]
    #[doc = " \\note This API is designed to support special memory with shape dependent layout."]
    #[doc = "       We pass in DLTensor* with shape information to support these cases."]
    #[doc = " \\param from The source tensor."]
    #[doc = " \\param to The target tensor."]
    #[doc = " \\param stream Optional stream object."]
    #[doc = " \\return 0 when success, -1 when failure happens."]
    pub fn TVMDeviceCopyDataFromTo(
        from: *mut DLTensor,
        to: *mut DLTensor,
        stream: TVMStreamHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check that an object is derived from another."]
    #[doc = " \\param child_type_index The type index of the derived type."]
    #[doc = " \\param parent_type_index The type index of the parent type."]
    #[doc = " \\param is_derived A boolean representing whether this predicate holds."]
    #[doc = " \\return 0 when success, -1 when failure happens."]
    pub fn TVMObjectDerivedFrom(
        child_type_index: u32,
        parent_type_index: u32,
        is_derived: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Signature for backend functions exported as DLL."]
#[doc = ""]
#[doc = " \\param args The arguments"]
#[doc = " \\param type_codes The type codes of the arguments"]
#[doc = " \\param num_args Number of arguments."]
#[doc = " \\param out_ret_value The output value of the the return value."]
#[doc = " \\param out_ret_tcode The output type code of the return value."]
#[doc = " \\param resource_handle Pointer to associated resource."]
#[doc = ""]
#[doc = " \\return 0 if success, -1 if failure happens, set error via TVMAPISetLastError."]
pub type TVMBackendPackedCFunc = ::std::option::Option<
    unsafe extern "C" fn(
        args: *mut TVMValue,
        type_codes: *mut ::std::os::raw::c_int,
        num_args: ::std::os::raw::c_int,
        out_ret_value: *mut TVMValue,
        out_ret_tcode: *mut ::std::os::raw::c_int,
        resource_handle: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief Backend function for modules to get function"]
    #[doc = "  from its environment mod_node (its imports and global function)."]
    #[doc = "  The user do should not call TVMFuncFree on func."]
    #[doc = ""]
    #[doc = " \\param mod_node The module handle."]
    #[doc = " \\param func_name The name of the function."]
    #[doc = " \\param out The result function."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMBackendGetFuncFromEnv(
        mod_node: *mut ::std::os::raw::c_void,
        func_name: *const ::std::os::raw::c_char,
        out: *mut TVMFunctionHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Backend function to register system-wide library symbol."]
    #[doc = ""]
    #[doc = " \\param name The name of the symbol"]
    #[doc = " \\param ptr The symbol address."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMBackendRegisterSystemLibSymbol(
        name: *const ::std::os::raw::c_char,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Backend function to allocate temporal workspace."]
    #[doc = ""]
    #[doc = " \\note The result allocated space is ensured to be aligned to kTempAllocaAlignment."]
    #[doc = ""]
    #[doc = " \\param nbytes The size of the space requested."]
    #[doc = " \\param device_type The device type which the space will be allocated."]
    #[doc = " \\param device_id The device id which the space will be allocated."]
    #[doc = " \\param dtype_code_hint The type code of the array elements. Only used in"]
    #[doc = " certain backends such as OpenGL."]
    #[doc = " \\param dtype_bits_hint The type bits of the array elements. Only used in"]
    #[doc = " certain backends such as OpenGL."]
    #[doc = " \\return nullptr when error is thrown, a valid ptr if success"]
    pub fn TVMBackendAllocWorkspace(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        nbytes: u64,
        dtype_code_hint: ::std::os::raw::c_int,
        dtype_bits_hint: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Backend function to free temporal workspace."]
    #[doc = ""]
    #[doc = " \\param ptr The result allocated space pointer."]
    #[doc = " \\param device_type The device type which the space will be allocated."]
    #[doc = " \\param device_id The device id which the space will be allocated."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    #[doc = ""]
    #[doc = " \\sa TVMBackendAllocWorkspace"]
    pub fn TVMBackendFreeWorkspace(
        device_type: ::std::os::raw::c_int,
        device_id: ::std::os::raw::c_int,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Environment for TVM parallel task."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct TVMParallelGroupEnv {
    #[doc = " \\brief Auxiliary used for synchronization"]
    pub sync_handle: *mut ::std::os::raw::c_void,
    #[doc = " \\brief total amount of task"]
    pub num_task: i32,
}
impl Default for TVMParallelGroupEnv {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = " \\brief The callback function to execute a parallel lambda"]
#[doc = " \\param task_id the task id of the function."]
#[doc = " \\param penv The parallel environment backs the execution."]
#[doc = " \\param cdata The supporting closure data."]
pub type FTVMParallelLambda = ::std::option::Option<
    unsafe extern "C" fn(
        task_id: ::std::os::raw::c_int,
        penv: *mut TVMParallelGroupEnv,
        cdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief Backend function for running parallel jobs."]
    #[doc = ""]
    #[doc = " \\param flambda The parallel function to be launched."]
    #[doc = " \\param cdata The closure data."]
    #[doc = " \\param num_task Number of tasks to launch, can be 0, means launch"]
    #[doc = "           with all available threads."]
    #[doc = ""]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMBackendParallelLaunch(
        flambda: FTVMParallelLambda,
        cdata: *mut ::std::os::raw::c_void,
        num_task: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief BSP barrrier between parallel threads"]
    #[doc = " \\param task_id the task id of the function."]
    #[doc = " \\param penv The parallel environment backs the execution."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMBackendParallelBarrier(
        task_id: ::std::os::raw::c_int,
        penv: *mut TVMParallelGroupEnv,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Simple static initialization function."]
    #[doc = "  Run f once and set handle to be not null."]
    #[doc = "  This function is mainly used for test purpose."]
    #[doc = ""]
    #[doc = " \\param handle A global address to indicate f"]
    #[doc = " \\param f The function to be run"]
    #[doc = " \\param cdata The closure data to pass to the function."]
    #[doc = " \\param nbytes Number of bytes in the closure data."]
    #[doc = " \\return 0 when no error is thrown, -1 when failure happens"]
    pub fn TVMBackendRunOnce(
        handle: *mut *mut ::std::os::raw::c_void,
        f: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        cdata: *mut ::std::os::raw::c_void,
        nbytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
